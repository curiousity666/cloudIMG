## C++Day9

### 一、友员

面向对象的四大基本特征：抽象、封装、继承、多态。

```C++
class Point
{
   friend void display(const Point &pt);
  public:
    void print()
    {
        
    }
  protected://继承的时候会使用到
  private:
    int _ix;
    int _iy;
};

Point  pt;

void display(const Point &pt)
{
    pt._ix = 100;
}

class Line
{
    
};
```

#### 1、形式

```C++
class A
{
  friend 函数原型;
  friend class B;
};
```

函数的分类：成员函数和非成员函数（自由函数、普通函数、全局函数）



```C++
namespace hh
{
    void display();//带命名空间的函数声明
}

namespace wd
{
    void print()
    {
        hh:display();
    }
}


namespace hh
{
    void display()
    {
        
    }
    
    void show()
    {
        wd::print();
    }
}
```



#### 2、友元的三种使用形式

##### 2.1、友元之普通函数的形式

1、![image-20220518103641983](43期C++笔记.assets/image-20220518103641983.png)

##### 2.2、友元之成员函数

![image-20220518111743228](43期C++笔记.assets/image-20220518111743228.png)

**显示调用构造函数会创建对象,创建对象的时候会调用构造函数 ok**

##### 2.3、友元之友元类

（一个类A的所有成员函数都是另外一个类B的友元，可以将A设置为B的友元）

![image-20220518112126595](43期C++笔记.assets/image-20220518112126595.png)

![image-20220518112656508](43期C++笔记.assets/image-20220518112656508.png)

#### 3、友元的特点

友元是单向的，友元不具有传递性（A->B->C）,友元关系不能被继承

友元的声明是不受public/protected/private关键字限制的



### 二、运算符重载

#### 1、形式

```C++
函数返回类型   operator运算符 (参数列表)
{
}

int add(int x, int y)//error
{
    
}

Complex operator+(const Complex &lhs, const Complex &rhs)//ok
{
 
}
```



#### 2、运算符重载的规则

2.1、进行运算符重载的时候，至少有一个是类类型或者枚举类型。

![image-20220518114814360](43期C++笔记.assets/image-20220518114814360.png)

2.2、运算符重载不能改变运算符的优先级与结合性

2.3、运算符重载不能改变操作数的位置、顺序（是在左边还是右边不能改变）、个数。

2.4、重载逻辑运算符（&&,||）后，不再具备短路求值特性。  

2.5、不能臆造不存在的运算符。



## C++Day10

### 一、不能重载的运算符有五个

1、成员访问运算符  .

2、成员指针运算符  .*

3、三目运算符  ?:

4、作用域限定符   ::

5、sizeof

![image-20220520095027438](43期C++笔记.assets/image-20220520095027438.png)

### 二、运算符重载的三种形式

#### 1、以普通函数的形式

![image-20220520101050569](43期C++笔记.assets/image-20220520101050569.png)

#### 2、以成员函数的形式

![image-20220520101444057](43期C++笔记.assets/image-20220520101444057.png)

#### 3、友元函数的形式

![image-20220520101941708](43期C++笔记.assets/image-20220520101941708.png)



### 三、特殊运算符的重载

#### 1、复合赋值运算符

![image-20220520103343109](43期C++笔记.assets/image-20220520103343109.png)

#### 2、前置++与后置++

![image-20220520111956694](43期C++笔记.assets/image-20220520111956694.png)

#### 3、输出（入）流运算符的重载

![image-20220520142312201](43期C++笔记.assets/image-20220520142312201.png)

![image-20220520144530683](43期C++笔记.assets/image-20220520144530683.png)

对于流对象而言，是不能进行拷贝操作的，或者说拷贝构造函数已经被删除了。

![image-20220520151344070](43期C++笔记.assets/image-20220520151344070.png)

![image-20220520151404903](43期C++笔记.assets/image-20220520151404903.png)

#### 4、重载函数调用运算符

必须是成员函数

```C++
int add(int x, int y)
    
    
int operator()(int x, int y)
{
    
}
```

![image-20220520153002435](43期C++笔记.assets/image-20220520153002435.png)



![image-20220520162042634](43期C++笔记.assets/image-20220520162042634.png)

#### 5、下标访问运算符的重载

![image-20220520165624204](43期C++笔记.assets/image-20220520165624204.png)



linux进行上传与下载的命令（对于小文件的传输可以使用）

![image-20220520174611847](43期C++笔记.assets/image-20220520174611847.png)



## C++Day11

### 一、问题回顾

1、友元的三种形式是什么？友元函数的性质？

2、哪些运算符不能被重载？运算符重载的规则有哪些？

3、几种特殊运算符的重载，有什么特点？



time函数

![image-20220521094354067](43期C++笔记.assets/image-20220521094354067.png)

```C++
template< class CharT, class Traits, class Alloc >
    basic_string<CharT,Traits,Alloc>
        operator+( const basic_string<CharT,Traits,Alloc>& lhs,
                   const CharT* rhs );


basic_string  operator+( const basic_string& lhs,const CharT* rhs );
```



### 二、特殊运算符重载

#### 6、箭头与解引用运算符的重载

![image-20220521112412274](43期C++笔记.assets/image-20220521112412274.png)





### 类型转换

#### 1、其他类型向自定义类型进行转换

![image-20220521114355623](43期C++笔记.assets/image-20220521114355623.png)



## C++Day12

### 一、问题回顾

1、友元的三种形式是什么？友元函数的性质？

2、哪些运算符不能被重载？运算符重载的规则有哪些？

3、几种特殊运算符的重载，有什么特点？

4、类型转换？



### 二、类型转换函数

从自定义类型向其他类型进行转换。

![image-20220523100156942](43期C++笔记.assets/image-20220523100156942.png)



### 三、类域

如果变量的名字不相同，此时变量的可见域与变量的作用域是等同的；但是如果变量名字相同的时候，变量的可见域是小于变量的作用域的。

![image-20220523103436791](43期C++笔记.assets/image-20220523103436791.png)



### 四、内部类

#### 4.1、定义

将一个类A的定义写到另外一个类B中，此时类A就是类B的内部类。

#### 4.2、例子

内部类的使用案例，pimpl

![image-20220523120029193](43期C++笔记.assets/image-20220523120029193.png)



### 五、单例模式的自动释放

#### 5.1、内存泄漏的检测工具valgrind

##### 安装

```Linux
sudo apt install valgrind
```

##### 使用

![image-20220523114535437](43期C++笔记.assets/image-20220523114535437.png)



#### 5.2、单例模式自动释放的四种方法

##### 1、友元类

![image-20220523143302819](43期C++笔记.assets/image-20220523143302819.png)

![image-20220523143237135](43期C++笔记.assets/image-20220523143237135.png)



##### 2、内部类 + 静态数据成员

![image-20220523145945424](43期C++笔记.assets/image-20220523145945424.png)



##### 3、饿汉模式 + atexit

![image-20220523150904105](43期C++笔记.assets/image-20220523150904105.png)![image-20220523152047280](43期C++笔记.assets/image-20220523152047280.png)

![image-20220523152109689](43期C++笔记.assets/image-20220523152109689.png)



##### 4、pthread_once + atexit

![image-20220523160447665](43期C++笔记.assets/image-20220523160447665.png)



### 六、string的底层实现

```C++
class String
{
public:
    String(const String &rhs)
     : _pstr(new char[strlen(rhs._pstr) + 1]())
     {
         strcpy(_pstr, rhs._pstr);
     }
 private:
  char *_pstr;  
};
String s1("hello");
String s2(s1);//深拷贝
String s3(s2);

//s1 s2 s3只是需要执行读操作，而不是写操作
//在执行读操作的时候，进行浅拷贝，在执行写操作的时候，进行深拷贝
```

写时复制：在执行写操作的时候，进行复制操作。使用**浅拷贝 + 引用计数**



在ubuntu14.04上使用了写时复制

![image-20220523162949650](43期C++笔记.assets/image-20220523162949650.png)

```C++
&pInt        0x7ffe0b50b948
s1'address = 0x7ffe0b50b960
s2'address = 0x7ffe0b50b980
s3'address = 0x55ff8da49e90
 pInt        0x55ff8da49e70
&pInt 0x7ffe0b50b948
pInt 0x55ff8da49e70

```

sso：短字符串优化，当字符串的长度小于等于15字节的时候，会存在栈上；当字符串的长度大于等于16字节的时候，存储在堆上。ubuntu18.04



#### 写时复制的关键在于引用计数的存放

![image-20220523180438184](43期C++笔记.assets/image-20220523180438184.png)



写代码时候的图解

![image-20220523180647916](43期C++笔记.assets/image-20220523180647916.png)

![image-20220523181027617](43期C++笔记.assets/image-20220523181027617.png)



赋值运算符与析构函数

![image-20220523181218529](43期C++笔记.assets/image-20220523181218529.png)



![image-20220523181544611](43期C++笔记.assets/image-20220523181544611.png)





## C++Day13

### 一、问题回顾

1、从自定义类型向其他类型转换？

```C++
Point pt(1, 2)

int ix = pt;

operator 目标类型()
{
    return 目标类型的变量;
}
```

2、类作用域的三种形式？内部类的使用

内部类，嵌套类  pimpl   

3、单例模式的自动释放？



4、string的实现？写时复制的技术关键在哪里？

深拷贝（浅拷贝）、写时复制（浅拷贝 + 引用计数）、短字符串优化



### 二、继承

#### 1、基本概念

面向对象的四大基本特征：抽象、封装、**继承**、多态。



animal    bird

C++中对于继承的含义：从既有类产生新类的过程。

既有类：基类（父类）

新类：派生类（子类）

#### 2、形式

```C++
class 派生类(子类) 
: public/protected/private 基类的类名（子类） //类派生列表
{
};

class  Son
: public Father
{
    
};
```

#### 3、派生类在创建过程中的三个步骤

1、**吸收**基类的成员

2、**改变**基类的成员

3、**新增**成员

成员：包括数据成员与成员函数（数据成员是可以被派生类吸收，有部分成员函数是不能被继承的）



#### 4、继承的局限性

1、友元关系是不能被继承

2、构造函数是不能被继承的，析构函数也是不能被继承的。

3、operator new与operator delete,operator=也是不能被继承的。



#### 5、不同派生方式对基类成员的访问

![image-20220524114625347](43期C++笔记.assets/image-20220524114625347.png)



![image-20220524120454877](43期C++笔记.assets/image-20220524120454877.png)

![image-20220524120736711](43期C++笔记.assets/image-20220524120736711.png)

![image-20220524120857960](43期C++笔记.assets/image-20220524120857960.png)



#### 6、保护继承与私有继承的区别

保护继承基类中的非私有成员，在以后可以无限继承下去；但是私有继承基类中的非私有成员，不能再继续继承下去。

默认的继承方式是私有的。



#### 7、派生类对象的构造与销毁

派生类构造函数的格式

```C++
派生类的构造函数名字(参数列表)
: 基类构造函数名字(参数列表)
{
};
```

![image-20220524145629775](43期C++笔记.assets/image-20220524145629775.png)



总结：不管基类与派生类有没有显示定义构造函数，当**创建派生类对象**的时候，会调用派生类自己的构造函数；为了**完成从基类这里吸收过来的数据成员的初始化**，**必须要调用基类的构造函数**（默认情况下，会调用基类的无参构造函数，而如果基类没有显示定义默认的构造函数，或者基类的默认构造函数没有提供的话，此时会报错）；而如果每次在派生类的构造函数的初始化列表中，**显示的写出基类的构造函数**，此时肯定就没有问题。

**必须将基类构造函数放在派生类构造函数的初试化列表中，以调用基类构造函数完成基类数据成员的初始化**  



##### 派生类构造函数的调用顺序

1、先分配空间 
2、调用基类构造函数完成基类数据成员的初始化
3、如果有特殊数据成员，const成员、引用成员、类对象数据成员，放在派生类构造函数的初始化列表中
4、在执行派生类构造函数的函数体

##### 派生类析构函数的调用顺序

1、先调用派生类的析构函数
2、再调用派生类中成员对象的析构函数
3、最后调用普通基类的析构函数  

当派生类对象进行销毁的时候，派生类的析构函数会被自动调用（完成派生类自己新增数据成员清理操作），然后**基类的析构函数会被自动调用**（作用是，为了完成从基类这里吸收过来的数据成员的清理操作）



#### 8、多基继承（多基派生）

##### 形式

```C++
class 派生类
: public/protected/private 基类1
,  public/protected/private 基类2
...
 public/protected/private 基类N
{
    
};
```



![image-20220524160353690](43期C++笔记.assets/image-20220524160353690.png)



![image-20220524160736255](43期C++笔记.assets/image-20220524160736255.png)

##### 经常会遇到的一个报错

![image-20220524161254112](43期C++笔记.assets/image-20220524161254112.png)



##### 多基派生产生的两个问题

![image-20220524161408210](43期C++笔记.assets/image-20220524161408210.png)

![image-20220524163732061](43期C++笔记.assets/image-20220524163732061.png)

![image-20220524163752283](43期C++笔记.assets/image-20220524163752283.png)



#### 9、基类与派生类对象间的转换

**类型适应**：类A可以适应类B的所有场景。**派生类可以适用于基类**

可以从派生类向基类进行转换

![image-20220524173702418](43期C++笔记.assets/image-20220524173702418.png)



但是不能从基类向派生类进行转换

![image-20220524173743790](43期C++笔记.assets/image-20220524173743790.png)



向上转型：派生类向基类进行转换。语法是支持的，并且都是安全的。

向下转型：基类向派生类进行转换。原本的语法是不支持，但是可以使用强制转换。

![image-20220524174652628](43期C++笔记.assets/image-20220524174652628.png)



基类对象与派生类对象在内存中的布局图（普通单继承）

![image-20220524174801184](43期C++笔记.assets/image-20220524174801184.png)

## C++Day14

### 一、问题回顾

1、派生类对象创建过程中的三个步骤？

吸收、改造、新增

2、不同继承方式下，对基类成员的访问？也就是那张表的总结

3、派生类对象构造时候需要注意什么？

4、多继承产生的两个问题？

5、基类与派生类对象之间可以进行转化吗？



### 二、关联式容器的使用

inputit  = input  iterator   迭代器   理解为一个广义指针，

一个类的使用类似于指针，那就证明该类里面已经重载了箭头（->）、解引用（*）、自增自减运算符（前置++，后置++，前置--，后置--，一次偏移n  +=   -=）

```C++
int arr[10] = {1, 2, 3};
set<int> number = {1, 2, 3};
```

![image-20220525100502503](43期C++笔记.assets/image-20220525100502503.png)

#### set的基本使用

![image-20220525110529087](43期C++笔记.assets/image-20220525110529087.png)

##### 初始化

![image-20220525101633842](43期C++笔记.assets/image-20220525101633842.png)

##### 遍历

![image-20220525101704341](43期C++笔记.assets/image-20220525101704341.png)

##### 查找

![image-20220525102530475](43期C++笔记.assets/image-20220525102530475.png)![image-20220525103259516](43期C++笔记.assets/image-20220525103259516.png)

##### set是不支持下标的

![image-20220525110001758](43期C++笔记.assets/image-20220525110001758.png)

##### set不支持修改

![image-20220525110448952](43期C++笔记.assets/image-20220525110448952.png)



#### map的使用

##### 基本概念

![image-20220525114412925](43期C++笔记.assets/image-20220525114412925.png)



##### 插入

![image-20220525112741315](43期C++笔记.assets/image-20220525112741315.png)



##### map的下标访问

![image-20220525113604632](43期C++笔记.assets/image-20220525113604632.png)

![image-20220525114320878](43期C++笔记.assets/image-20220525114320878.png)



## C++Day15

### 一、派生类对象之间的复制控制

1、如果用户定义了基类的拷贝构造函数，而没有定义派生类的拷贝构造函数，那么在用一个派生类对
象初始化新的派生类对象时，两对象间的派生类部分执行缺省的行为，而两对象间的基类部分执行
用户定义的基类拷贝构造函数。

2、如果用户重载了基类的赋值运算符函数，而没有重载派生类的赋值运算符函数，那么在用一个派生
类对象给另一个已经存在的派生类对象赋值时，两对象间的派生类部分执行缺省的赋值行为，而两
对象间的基类部分执行用户定义的重载赋值函数。

![image-20220526104911425](43期C++笔记.assets/image-20220526104911425.png)



3、如果用户定义了派生类的拷贝构造函数或者重载了派生类的对象赋值运算符=，则在用已有派生类
对象初始化新的派生类对象时，或者在派生类对象间赋值时，将会执行用户定义的派生类的拷贝构
造函数或者重载赋值函数，而不会再自动调用基类的拷贝构造函数和基类的重载对象赋值运算符，
这时，通常需要用户在派生类的拷贝构造函数或者派生类的赋值函数中显式调用基类的拷贝构造或
赋值运算符函数。

![image-20220526102235944](43期C++笔记.assets/image-20220526102235944.png)



![image-20220526102257302](43期C++笔记.assets/image-20220526102257302.png)



### 二、写时复制区分读写

![image-20220526112210207](43期C++笔记.assets/image-20220526112210207.png)



![image-20220526112304019](43期C++笔记.assets/image-20220526112304019.png)

![image-20220526142841750](43期C++笔记.assets/image-20220526142841750.png)



### 三、阅读第三方库的方式

1、找到相应的头文件目录与实现文件目录（找源码，可以完全掌控第三方库的原理）

2、可以看看是不是有测试文件（加快该第三方库的使用）

3、需要找main函数，main函数是入口函数（找到突破口）

4、别人是怎么样使用该第三方库的。参考其中的例子



```C++
template< class Traits, class CharT,
          class STraits, class SAlloc,
          class FTraits, class FAlloc >
std::basic_string<CharT,STraits,SAlloc>
    regex_replace( const std::basic_string<CharT,STraits,SAlloc>& s,
                   const std::basic_regex<CharT,Traits>& re,
                   const std::basic_string<CharT,FTraits,FAlloc>& fmt,
                   std::regex_constants::match_flag_type flags =
                       std::regex_constants::match_default );



std::basic_string
    regex_replace( const std::basic_string& s,
                   const std::basic_regex& re,
                   const std::basic_string& fmt,
                   std::regex_constants::match_flag_type flags =
                       std::regex_constants::match_default );
```



### 四、多态

#### 1、基本概念

多态：**对于同一种指令**（警车鸣笛），针对**不同的对象**（警察、普通人、嫌疑犯），产生**不一样的行为**（追捕行动、该干什么干什么、逃跑）。



#### 2、多态的类型

静态多态：包括函数重载、运算符重载、模板。**发生的时机在编译的时候**。

```C++
int add(int, int);
double add(double, double);
string add(string, string);


string operator+(string, string);
Point operator+(Point, Point);
Complex operator+(Complex, Complex);

add(1, 2);
add(1.1, 2.2);
```

动态多态：**发生的时机在运行时**。虚函数



#### 3、虚函数的概念

在**成员函数**的前面加上**virtual**的函数称为虚函数。

```C++
class A
{
  public:
    virtual void print(int x, double y)
    {
        //......
    }
};

class B
: public A
{
   //print
    virtual void print(int x, double y)
    {
        //.....
    }
};
```

当派生类继承基类的时候，基类的虚函数会被派生类继承，该虚函数在派生类里面仍然是虚函数，即使在派生类中不加virtual关键字，该函数仍然是虚函数。

派生类**重定义**虚函数的时候，格式非常严格

1、函数名字要相同

2、函数的参数列表要完全相同（参数的个数、参数的类型、参数顺序）

3、函数的返回类型也必须相同

总结：除了函数的函数体可以不一样之外，其他的都必须一样



#### 4、虚函数的原理（动态多态的原理）

![image-20220526161135992](43期C++笔记.assets/image-20220526161135992.png)

当基类定义了虚函数的时候，就会在基类的对象的存储布局前面多一个虚函数指针，该虚函数指针指向基类自己的虚函数表（也称为虚表），该虚表存放的是虚函数的入口地址；当派生类继承基类的时候，会吸收基类中的虚函数，此时派生类自己也会有自己的虚函数，有虚函数就会在派生类对象的存储布局前面产生一个虚函数指针，该虚函数指针会指向派生类自己的虚函数表，派生类自己的虚表存放是是自己的虚函数的入口地址，如果此时派生类重定义了该虚函数，就会用派生类自己的虚函数的地址去覆盖从基类吸收过来的虚函数的入口地址。



#### 5、虚函数被激动的五个条件

1、基类要定义虚函数
2、派生类要重定义（重写、覆盖）该虚函数
3、创建派生类对象
4、用基类的指针（引用）指向（绑定）派生类的对象
5、用基类的指针（引用）调用虚函数



#### 6、哪些函数不能被设计为虚函数

1、普通函数（自由函数、全局函数）（非成员函数）：虚函数必须是一个成员函数。

2、静态成员函数：从发生时机上看，静态函数调用时机在编译的时候，而虚函数要体现动态多态，发生时机在运行时候；静态成员函数没有this；

3、内联成员函数：发生时机在编译时候，而虚函数要体现动态多态，在运行的时候；如果将内联函数设置为虚函数，此时该内联函数已经失去内联的含义。

4、友元函数。如果友元函数本身是一个普通函数，就不能被设置为虚函数；但是如果友元函数本身是一个成员函数，它是可以被设置为虚函数的。

![image-20220526165215120](43期C++笔记.assets/image-20220526165215120.png)

5、构造函数：发生的时机在编译的时候，而虚函数要体现动态多态，发生的时机在运行时候；如果将构造函数设置为函数，需要在虚表中存放虚函数的入口地址，需要通过虚函数指针找到虚表，而虚函数指针位于对象的内存布局的前面，而构造函数不调用，对象本身是不完整的（初始化还没有成功，在内存中的布局还不完整），就不知道虚函数指针是否存在，就不能找到虚表，就不能调用虚函数；从继承角度看，构造函数不能被继承，而虚函数是可以被继承的。



#### 7、虚函数的访问

1、使用指针调用虚函数，可以体现出多态

2、使用引用调用虚函数，可以体现出多态

3、对象调用虚函数，没有体现多态

4、可以使用其他成员函数调用虚函数，可以体现动态多态。

![image-20220526173512253](43期C++笔记.assets/image-20220526173512253.png)

5、使用构造函数与析构函数调用虚函数，没有体现多态。



对象的销毁与析构函数的执行是不是等价的？

栈对象的，等价；堆对象，析构函数的执行只是对象销毁一部分。

虚函数与动态多态是不是等价吧？

动态多态的体现必须要有虚函数；但是有虚函数并不一定体现动态多态。



## C++Day16

### 一、问题回顾

1、动态多态的原理（虚函数机制）？

2、动态多态被激活的五个条件

3、哪些函数不能被设计为虚函数？

定义相符合、从发生时机、从继承的角度、看函数本身的性质



```C++
class A
{ 
public:
    virtual
    void func(int val = 1)
    {
        cout << "A->" << val << endl;
        int b = 10;
    } 
    
    virtual 
    void test()
    {
        func();
    }
private:
    long _a;
};

class B
: public A
{ 
public:
    virtual
    void func(int val = 10)
    {
        val += 1;
        cout << "B->" << val << endl;
    }
private:
    long _b;
};

int main(void)
{
    B b;
    A *p1 = (A*)&b;
    B *p2 = &b;
    
    p1->func();
    p2->func();
    
    return 0;
}
```

虚函数的函数体才有可能在运行时确定，其他的全部在编译时候就确定，包括函数的参数。



### 二、抽象类

抽象类是作为接口使用的

![image-20220527100131500](43期C++笔记.assets/image-20220527100131500.png)



![image-20220527100206275](43期C++笔记.assets/image-20220527100206275.png)

![image-20220527100422629](43期C++笔记.assets/image-20220527100422629.png)





抽象类作为接口使用的例子

![image-20220527102422740](43期C++笔记.assets/image-20220527102422740.png)

抽象类的第二种形式

构造函数设置为protected

![image-20220527102932538](43期C++笔记.assets/image-20220527102932538.png)



Category &root = Category::getRoot();



### 三、虚析构函数

为了解决内存泄漏。

![image-20220527112940504](43期C++笔记.assets/image-20220527112940504.png)

![image-20220527112750434](43期C++笔记.assets/image-20220527112750434.png)



### 四、三个重要概念

重载：在**同一个作用域**中，**函数名字相同**，**参数列表不一样**（参数类型、参数个数、参数顺序）（单靠返回类型不能区分重载）

覆盖（重定义、重写）：在基类与派生类中，**虚函数**的名字与参数列表都要一样。

隐藏：在基类与派生类中，派生类中的函数屏蔽了基类中的**同名函数**。（同名的数据成员也可以发生隐藏）

![image-20220527115300640](43期C++笔记.assets/image-20220527115300640.png)

![image-20220527115352583](43期C++笔记.assets/image-20220527115352583.png)

![image-20220527115417965](43期C++笔记.assets/image-20220527115417965.png)





### 五、虚表的存在

```C++
Base(long = 0)
Derived(long  = 0, long = 0)
Derived的地址 : 0x7fff28d10e60
Derived的地址 : 0x7fff28d10e60

derived2的地址 : 0x7fff28d10e80
derived2的地址 : 0x7fff28d10e80
   
    
虚表的地址 : 0x55f3486b2d00
虚表的地址 : 0x55f3486b2d00
    
第一个虚函数的地址 : 0x55f3484b20ea
第一个虚函数的地址 : 0x55f3484b20ea

Derived::f()
第一个虚函数的入口地址: 0x55f3484b20ea

Derived::g()
第二个虚函数的入口地址: 0x55f3484b2122

Derived::h()
第三个虚函数的入口地址: 0x55f3484b215a


Base(long = 0)
Derived(long  = 0, long = 0)
derived2的地址 : 0x7fff28d10e80
derived2的地址 : 0x7fff28d10e80
虚表的地址 : 0x55f3486b2d00
第一个虚函数的地址 : 0x55f3484b20ea
~Derived()
~Base()
~Derived()
~Base()
```

![image-20220527150346800](43期C++笔记.assets/image-20220527150346800.png)

![image-20220527150906382](43期C++笔记.assets/image-20220527150906382.png)



### 六、多基派生的二义性

如何验证一个函数是不是虚函数？

可以再继续的写一个派生类，让其继承，并将该函数重新在派生类中实现一次。

![image-20220527161138572](43期C++笔记.assets/image-20220527161138572.png)

![image-20220527161155196](43期C++笔记.assets/image-20220527161155196.png)

![image-20220527161234282](43期C++笔记.assets/image-20220527161234282.png)



```C++
1>B::$vbtable@:
1> 0	| 0      //虚基指针距离派生类对象首地址的偏移信息
1> 1	| 8 (Bd(B+0)A)  //虚基指针距离虚基类的偏移值
```



## C++Day17

### 一、问题回顾

1、抽象类的两种方式？

2、虚析构函数解决了什么问题？为什么析构函数可以设置为虚函数？

3、隐藏与覆盖的区别？

4、虚表存在性的验证？

5、如何验证一个函数是不是虚函数？



### 二、继承多态的内存布局

#### 1、普通继承与虚拟继承的区别？

虚拟继承会多一个**虚基指针**，虚基指针指向虚基表，虚基表中存放的是虚基指针距离派生类对象首地址的偏移信息，以及虚基指针距离虚基类的偏移信息；此时派生类对象的数据成员存放在基类数据成员的前面![image-20220528095353592](43期C++笔记.assets/image-20220528095353592.png)



#### 2、普通继承的时候，派生类有新增虚函数？

![image-20220528095750787](43期C++笔记.assets/image-20220528095750787.png)



![image-20220528100223445](43期C++笔记.assets/image-20220528100223445.png)



#### 3、虚拟继承，基类带虚函数，派生有新增虚函数

![image-20220528100750741](43期C++笔记.assets/image-20220528100750741.png)![image-20220528100902529](43期C++笔记.assets/image-20220528100902529.png)

总结：有虚函数就会有虚函数指针，有虚拟继承就会有虚基指针，虚函数指针指向虚函数表，虚基指针指向虚基表。

如果是**普通继承**的话，**基类的布局形式**会存在派生类对象的**前面**，派生类的布局形式就会排在后面。如果派生类自己新增虚函数，对派生对象的大小是没有影响的，新增虚函数只会存在之前的虚表中。

如果是**虚拟继承**的话，**派生类的布局**形式会在派生类对象的**前面**，基类的布局形式在后面。如果派生类有**新增虚函**数，**派生类对象的大小会发生变化**，会多产生一个虚函数指针，用来存放新的虚函数的入口地址。



#### 4、普通多继承

![image-20220528102512029](43期C++笔记.assets/image-20220528102512029.png)![image-20220528102552197](43期C++笔记.assets/image-20220528102552197.png)



#### 5、棱形继承

存在的存储二义性的问题

![image-20220528112015908](43期C++笔记.assets/image-20220528112015908.png)

虚拟继承解决棱形继承产生的存储二义性问题

![image-20220528113402719](43期C++笔记.assets/image-20220528113402719.png)



![image-20220528113456647](43期C++笔记.assets/image-20220528113456647.png)



### 三、虚拟继承

#### 虚拟继承的形式

```C++
class Derived
: virtual public/protected/private Base
{
  //  
};
```



虚拟继承与虚函数中的virtual的关系，二者都表示**存在、间接、共享**

#### 虚函数中的虚

1、虚函数是存在的
2、虚函数必须要通过一种间接的运行时（而不是编译时）机制才能够激活（调用）的函数（虚表）
3、共享性表现在基类会共享被派生类重定义后的虚函数

#### 虚拟继承中的虚

1、存在即表示虚继承体系和虚基类确实存在
2、间接性表现在当访问虚基类的成员时同样也必须通过某种间接机制来完成（通过虚基表来完成）
3、共享性表现在虚基类会在虚继承体系中被共享，而不会出现多份拷贝（最终的派生类负责虚基类的数据成员的初始化）

![image-20220528120908627](43期C++笔记.assets/image-20220528120908627.png)

![image-20220528120943775](43期C++笔记.assets/image-20220528120943775.png)![image-20220528121020275](43期C++笔记.assets/image-20220528121020275.png)





## C++Day18

### 一、移动语义

#### 1、左值与右值的概念

左值：可以取地址。

右值：不能进行取地址。包括临时变量、临时对象（string("world")）、字面值常量。

左值引用：int &ref = a;左值引用可以绑定到左值，但是不能绑定到右值（int &ref1 = 10,error）

const左值引用：const  int &ref = a;  const int &ref = 10;const左值引用既可以绑定到左值，也可以绑定到右值。

**右值引用：右值引用可以识别右值，但是不能识别左值。**

**右值引用本身可以是左值，可以进行取地址（int &&ref = 10）,但是右值引用也可能是右值（函数的返回参数是右值引用的情况）**

```C++
int &&func()
{
    return 10;
}
&func();//error,右值引用本身也可以是右值
```



![image-20220530103539706](43期C++笔记.assets/image-20220530103539706.png)



#### 2、移动构造函数

![image-20220530105342794](43期C++笔记.assets/image-20220530105342794.png)



#### 3、移动赋值函数

![image-20220530115200422](43期C++笔记.assets/image-20220530115200422.png)



#### 4、移动语义总结

拷贝构造函数与赋值运算符函数，编译器会自动提供；但是移动构造函数与移动赋值运算符函数，编译器不会自动提供，必须要手写。

将拷贝构造函数与赋值运算符函数称为具有拷贝控制语义的函数；将移动构造函数与移动赋值运算符函数称为具有移动语义的函数。

移动语义的函数优先于拷贝语义的函数。



#### 5、左值右值再探

```C++
&cx = 0x56148ef3e388
&c =    0x7ffd7c8b50fc
&cy =   0x7ffd7c8b50f8
&pstr = 0x7ffd7c8b5100
pstr =   0x56148ef3e37c
&cx =    0x56148ef3e388
```

![image-20220530111405031](43期C++笔记.assets/image-20220530111405031.png)

总结：文字常量区的变量，并不一定是字符串，有可能是const修饰的全局变量；用const修饰的变量并不一定位于内存中的同一块区域。

![image-20220530111558354](43期C++笔记.assets/image-20220530111558354.png)



#### 6、std::move的特点

![image-20220530111939415](43期C++笔记.assets/image-20220530111939415.png)



### 二、资源管理

#### RAII的特征

1、在构造函数中初始化资源，或者托管资源

![image-20220530155120817](43期C++笔记.assets/image-20220530155120817.png)

2、在析构函数中释放资源

![image-20220530155143911](43期C++笔记.assets/image-20220530155143911.png)

3、提供若干访问资源的方法

![image-20220530155206941](43期C++笔记.assets/image-20220530155206941.png)

![image-20220530155224120](43期C++笔记.assets/image-20220530155224120.png)

4、不允许复制与赋值（对象语义）：将拷贝构造函数与赋值运算符函数删除或者设置为私有的。

![image-20220530155240282](43期C++笔记.assets/image-20220530155240282.png)

值语义：可以进行复制与赋值

对象语义：不能进行复制与赋值。

![image-20220530155310441](43期C++笔记.assets/image-20220530155310441.png)

#### RAII的本质

利用栈对象的生命周期进行管理资源。





![image-20220530151407651](43期C++笔记.assets/image-20220530151407651.png)



### 三、智能指针

#### 1、auto_ptr

```C++
//auto_ptr<int> ap2(ap); 
auto_ptr(auto_ptr& __a) 
  : _M_ptr(__a.release()) 
  {

  }
//ap
_Tp* release()  {
    _Tp* __tmp = _M_ptr;
    _M_ptr = nullptr;
    return __tmp;
  }
```

![image-20220530152320000](43期C++笔记.assets/image-20220530152320000.png)



#### 2、unique_ptr

![image-20220530152621292](43期C++笔记.assets/image-20220530152621292.png)

1、在语法层面不允许复制或者赋值

2、unique_ptr具有移动语义（具有移动构造函数与移动赋值函数），可以作为容器的元素

![image-20220530153240676](43期C++笔记.assets/image-20220530153240676.png)



#### 3、shared_ptr

使用引用技术统计指向同一块空间的shared_ptr对象的个数

1、可以进行复制或者赋值

![image-20220530162008914](43期C++笔记.assets/image-20220530162008914.png)

2、shared_ptr也具有移动语义，也可以作为容器的元素

![image-20220530162118376](43期C++笔记.assets/image-20220530162118376.png)

3、循环引用

可能造成内存泄漏，可以使用weak_ptr与shared_ptr进行结合使用，weak_ptr不会是增加引用计数

![image-20220530165321332](43期C++笔记.assets/image-20220530165321332.png)

![image-20220530165447735](43期C++笔记.assets/image-20220530165447735.png)

#### 4、weak_ptr

不会增加引用计数，属于弱引用。

**不能直接托管裸指针**，只能从shared_ptr去进行复制或者赋值，或者从其他的weak_ptr复制或者赋值。

判断weak_ptr托管的资源还存在与否，可以使用lock函数或者expired函数。

![image-20220530173710419](43期C++笔记.assets/image-20220530173710419.png)



#### ![image-20220530173727469](43期C++笔记.assets/image-20220530173727469.png)5、删除器

![image-20220530175353590](43期C++笔记.assets/image-20220530175353590.png)



```C++
template< class Y, class Deleter >
shared_ptr( Y* ptr, Deleter d );
```

![image-20220530175922219](43期C++笔记.assets/image-20220530175922219.png)



## C++Day19

### 一、问题回顾

1、左值与右值的区别？

能不能进行取地址。

2、什么是左值引用？什么是右值引用？什么是const左值引用？有什么特点

```C++
int a = 10;
int &ref = a;
int &ref1 = 10;//error
const int &ref = a;//ok
const int &ref = 10;//ok

int &&rref = 10;//ok
int &&rref2 = a;//error

String s1 = String("world");

String(String &rhs);
String(String &&rhs)
```



3、移动构造函数与移动赋值运算符函数？

将函数的参数换成右值引用，将深拷贝换成浅拷贝



4、std::move的特点？作用？

将左值转换为右值，实质：就是做了强制转换。

```C++
s1 = std::move(s1);
String &operator=(String &&rhs)//右值引用可以延长右值的生命周期
{
    
}
```



5、RAII的思想是什么？有什么特征？

利用栈对象的生命周期管理资源。



6、四种智能指针的特点与缺陷？

auto_ptr：缺陷

unique_ptr：在语法层面不允许复制或者赋值。具有移动语义。

shared_ptr：共享所有权的智能指针，可以进行复制或者赋值。使用引用计数。

缺陷：循环引用。shared_ptr与weak_ptr的结合，解决循环引用。

weak_ptr：没有重载-> *     wp提升为sp  lock     expired （use_count == 0）

7、什么是删除器，为何要定义删除器？

unique_ptr  shared_ptr



### 二、智能指针

#### 智能指针的误用

![image-20220531095534690](43期C++笔记.assets/image-20220531095534690.png)





![image-20220531095757922](43期C++笔记.assets/image-20220531095757922.png)

![image-20220531095940908](43期C++笔记.assets/image-20220531095940908.png)

不同的share_ptr也不能直接托管同一个裸指针

![image-20220531100224696](43期C++笔记.assets/image-20220531100224696.png)![image-20220531100350104](43期C++笔记.assets/image-20220531100350104.png)



![image-20220531102116462](43期C++笔记.assets/image-20220531102116462.png)![image-20220531102210005](43期C++笔记.assets/image-20220531102210005.png)

![image-20220531102342270](43期C++笔记.assets/image-20220531102342270.png)



## C++Day20

### 一、模板

```C++
int add(int x, int y)
{
    return x + y;
}

double add(double x, double y)
{
    return x + y;
}

long add(long x, long y)
{
    return x + y;
}

string add(string x, string y)
{
    return x + y;
}

//T1 = T2 = T3
T3 add(T1 x, T2 y)
{
    return x + y;
}
```

#### 为什么要定义模板

1、简化代码，少写代码

2、可以解决严格性与灵活性的冲突。



强类型语言：C/C++/Java，int a = 10;有严格类型要求，auto a = 10;

弱类型语言：js/py  ,   var a = 10

#### 形式

```C++
//例子：函数模板
template <模板参数列表>
函数的返回类型   函数名字(函数的参数列表)
{
}


template <typename T1, typename T2，...>
template <class T1, class T2，...>
//模板参数列表中typename与class的含义是完全一样
```



#### 模板的类型

函数模板、类模板



#### 函数模板

```C++
template <typename T>
T add(T x, T y)
{
    
}
```

![image-20220601101054616](43期C++笔记.assets/image-20220601101054616.png)



![image-20220601101130587](43期C++笔记.assets/image-20220601101130587.png)

模板不能分成头文件与实现文件的形式

![image-20220601100904676](43期C++笔记.assets/image-20220601100904676.png)



![image-20220601102652911](43期C++笔记.assets/image-20220601102652911.png)

全特化：将模板的参数列表中的参数全部以特殊版本的形式写出来；

偏特化（部分特化）：将模板参数列表中的参数类型，至少有一个没有特化出来。

![image-20220601102808407](43期C++笔记.assets/image-20220601102808407.png)



#### 模板的参数类型

![image-20220601105135806](43期C++笔记.assets/image-20220601105135806.png)



#### 成员函数模板

![image-20220601110506104](43期C++笔记.assets/image-20220601110506104.png)



#### 类模板

```C++
template <typename T>
class Stack
{
 private:
    T *_data;
};
```



#### 可变模板参数

```C++
template <typename ...Args>//Args模板参数包
void func(Args ...args)//args函数参数包
{
    
}

template <typename T1, typename T2, typename T3,...>
void func(T1 t1, T2 t2, T3 t3,...)
{
    
}
```

![image-20220601112912856](43期C++笔记.assets/image-20220601112912856.png)

![image-20220601112837405](43期C++笔记.assets/image-20220601112837405.png)
